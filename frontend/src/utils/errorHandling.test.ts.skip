import { errorLogger, ErrorType, withErrorHandling } from './errorHandling';

describe('ErrorLogger', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('getInstance', () => {
    it('should return a singleton instance', () => {
      expect(errorLogger).toBeDefined();
    });
  });


  describe('logError', () => {
    beforeEach(() => {
      // Mock console methods
      jest.spyOn(console, 'error').mockImplementation();
      jest.spyOn(console, 'warn').mockImplementation();
      jest.spyOn(console, 'log').mockImplementation();
    });

    it('should log error with correct details', () => {
      const errorDetails = {
        message: 'Test error',
        userMessage: 'Something went wrong',
        component: 'TestComponent',
        action: 'testAction'
      };

      const loggedError = errorLogger.logError(errorDetails);

      expect(loggedError.id).toBeDefined();
      expect(loggedError.timestamp).toBeDefined();
      expect(loggedError.message).toBe('Test error');
      expect(loggedError.userMessage).toBe('Something went wrong');
      expect(loggedError.component).toBe('TestComponent');
      expect(loggedError.action).toBe('testAction');
      expect(loggedError.type).toBe(ErrorType.SYSTEM);
    });

    it('should categorize error based on error object', () => {
      const errorDetails = {
        message: 'Network error',
        userMessage: 'Connection failed',
        error: { code: 'NETWORK_ERROR' }
      };

      const loggedError = errorLogger.logError(errorDetails);
      expect(loggedError.type).toBe(ErrorType.NETWORK);
    });

    it('should include stack trace if available', () => {
      const error = new Error('Test error');
      const errorDetails = {
        message: 'Test error',
        userMessage: 'Something went wrong',
        error
      };

      const loggedError = errorLogger.logError(errorDetails);
      expect(loggedError.stack).toBe(error.stack);
    });
  });

  describe('handleError', () => {
    beforeEach(() => {
      jest.spyOn(console, 'error').mockImplementation();
    });

    it('should handle error and return error details', () => {
      const error = new Error('Test error');
      const context = {
        component: 'TestComponent',
        action: 'testAction',
        userMessage: 'Something went wrong'
      };

      const errorDetails = errorLogger.handleError(error, context);

      expect(errorDetails.message).toBe('Test error');
      expect(errorDetails.component).toBe('TestComponent');
      expect(errorDetails.action).toBe('testAction');
      expect(errorDetails.userMessage).toBe('Something went wrong');
    });

    it('should handle axios errors with response', () => {
      const axiosError = {
        response: {
          status: 400,
          data: { message: 'Bad request' }
        },
        message: 'Request failed'
      };

      const errorDetails = errorLogger.handleError(axiosError);
      expect(errorDetails.type).toBe(ErrorType.VALIDATION);
    });
  });
});

describe('withErrorHandling', () => {
  let mockAsyncFunction: jest.Mock;

  beforeEach(() => {
    mockAsyncFunction = jest.fn();
    jest.spyOn(errorLogger, 'handleError').mockImplementation(() => ({
      id: 'test-id',
      timestamp: new Date(),
      message: 'Test error',
      userMessage: 'Something went wrong',
      type: ErrorType.SYSTEM,
      component: 'TestComponent'
    } as any));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should execute function successfully when no error occurs', async () => {
    const expectedResult = { data: 'success' };
    mockAsyncFunction.mockResolvedValue(expectedResult);

    const wrappedFunction = withErrorHandling(mockAsyncFunction, {
      component: 'TestComponent',
      action: 'testAction'
    });

    const result = await wrappedFunction();
    expect(result).toEqual(expectedResult);
    expect(mockAsyncFunction).toHaveBeenCalledTimes(1);
  });

  it('should handle errors and rethrow them', async () => {
    const error = new Error('Test error');
    mockAsyncFunction.mockRejectedValue(error);

    const wrappedFunction = withErrorHandling(mockAsyncFunction, {
      component: 'TestComponent',
      action: 'testAction'
    });

    await expect(wrappedFunction()).rejects.toThrow('Test error');
    expect(errorLogger.handleError).toHaveBeenCalledWith(error, {
      component: 'TestComponent',
      action: 'testAction'
    });
  });

  it('should pass arguments to wrapped function', async () => {
    const expectedResult = { data: 'success' };
    mockAsyncFunction.mockResolvedValue(expectedResult);

    const wrappedFunction = withErrorHandling(mockAsyncFunction, {
      component: 'TestComponent'
    });

    await wrappedFunction('arg1', 'arg2', 123);
    expect(mockAsyncFunction).toHaveBeenCalledWith('arg1', 'arg2', 123);
  });
});