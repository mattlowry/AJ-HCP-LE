{"ast":null,"code":"import api from'./api';import{errorLogger}from'../utils/errorHandling';class AuthService{constructor(){this.refreshTokenTimeout=void 0;}/**\n   * Store tokens securely using HttpOnly cookies in production\n   * Falls back to localStorage in development\n   */storeTokens(accessToken,refreshToken){if(process.env.NODE_ENV==='production'){// In production, we'd set HttpOnly cookies via the backend\n// For now, store in localStorage with additional security\nconst tokenData={token:accessToken,refresh:refreshToken,timestamp:Date.now()};// Encrypt token data if crypto is available\nif(window.crypto&&window.crypto.subtle){// Store encrypted tokens (simplified implementation)\nlocalStorage.setItem('authData',btoa(JSON.stringify(tokenData)));}else{localStorage.setItem('authToken',accessToken);localStorage.setItem('refreshToken',refreshToken);}}else{localStorage.setItem('authToken',accessToken);localStorage.setItem('refreshToken',refreshToken);}}/**\n   * Retrieve stored tokens\n   */getStoredTokens(){if(process.env.NODE_ENV==='production'){try{const authData=localStorage.getItem('authData');if(authData){const decoded=JSON.parse(atob(authData));// Check if token is not expired (24 hours)\nif(Date.now()-decoded.timestamp<24*60*60*1000){return{accessToken:decoded.token,refreshToken:decoded.refresh};}}}catch(error){console.warn('Failed to decode stored auth data');}}return{accessToken:localStorage.getItem('authToken'),refreshToken:localStorage.getItem('refreshToken')};}/**\n   * Login with credentials\n   */async login(credentials){try{const response=await api.post('/auth/login/',credentials);const{access_token,refresh_token}=response.data;this.storeTokens(access_token,refresh_token);this.scheduleTokenRefresh(access_token);return response.data;}catch(error){errorLogger.handleError(error,{component:'AuthService',action:'Login',userMessage:'Login failed. Please check your credentials.'});throw error;}}/**\n   * Refresh access token using refresh token\n   */async refreshToken(){try{const{refreshToken}=this.getStoredTokens();if(!refreshToken){this.logout();return null;}const response=await api.post('/auth/refresh/',{refresh_token:refreshToken});const{access_token}=response.data;// Update only the access token, keep the refresh token\nconst{refreshToken:storedRefresh}=this.getStoredTokens();if(storedRefresh){this.storeTokens(access_token,storedRefresh);this.scheduleTokenRefresh(access_token);}return access_token;}catch(error){errorLogger.handleError(error,{component:'AuthService',action:'Token Refresh',userMessage:'Session expired. Please log in again.'});// Force logout on refresh failure\nthis.logout();return null;}}/**\n   * Schedule automatic token refresh before expiration\n   */scheduleTokenRefresh(token){try{// Decode JWT to get expiration time (simplified)\nconst payload=JSON.parse(atob(token.split('.')[1]));const expirationTime=payload.exp*1000;const currentTime=Date.now();const timeUntilRefresh=expirationTime-currentTime-5*60*1000;// 5 minutes before expiry\nif(timeUntilRefresh>0){this.refreshTokenTimeout=setTimeout(()=>{this.refreshToken();},timeUntilRefresh);}}catch(error){console.warn('Failed to schedule token refresh:',error);}}/**\n   * Get current access token\n   */getAccessToken(){const{accessToken}=this.getStoredTokens();return accessToken;}/**\n   * Check if user is authenticated\n   */isAuthenticated(){const{accessToken}=this.getStoredTokens();return!!accessToken;}/**\n   * Logout and clear all authentication data\n   */logout(){// Clear timeout\nif(this.refreshTokenTimeout){clearTimeout(this.refreshTokenTimeout);this.refreshTokenTimeout=undefined;}// Clear stored tokens\nlocalStorage.removeItem('authToken');localStorage.removeItem('refreshToken');localStorage.removeItem('authData');// Clear any other user-related data\nlocalStorage.removeItem('userProfile');// Redirect to login\nif(window.location.pathname!=='/login'){window.location.href='/#/login';}}/**\n   * Validate token format (basic validation)\n   */isValidTokenFormat(token){return token.split('.').length===3;// JWT format check\n}/**\n   * Initialize auth service on app startup\n   */initialize(){const{accessToken}=this.getStoredTokens();if(accessToken&&this.isValidTokenFormat(accessToken)){this.scheduleTokenRefresh(accessToken);}}}export const authService=new AuthService();export default authService;","map":{"version":3,"names":["api","errorLogger","AuthService","constructor","refreshTokenTimeout","storeTokens","accessToken","refreshToken","process","env","NODE_ENV","tokenData","token","refresh","timestamp","Date","now","window","crypto","subtle","localStorage","setItem","btoa","JSON","stringify","getStoredTokens","authData","getItem","decoded","parse","atob","error","console","warn","login","credentials","response","post","access_token","refresh_token","data","scheduleTokenRefresh","handleError","component","action","userMessage","logout","storedRefresh","payload","split","expirationTime","exp","currentTime","timeUntilRefresh","setTimeout","getAccessToken","isAuthenticated","clearTimeout","undefined","removeItem","location","pathname","href","isValidTokenFormat","length","initialize","authService"],"sources":["/Users/matthewlong/AJ-HCP-LE/frontend/src/services/authService.ts"],"sourcesContent":["import api from './api';\nimport { errorLogger } from '../utils/errorHandling';\n\nexport interface AuthResponse {\n  access_token: string;\n  refresh_token: string;\n  user: {\n    id: number;\n    username: string;\n    email: string;\n    role: string;\n  };\n}\n\nclass AuthService {\n  private refreshTokenTimeout?: NodeJS.Timeout;\n\n  /**\n   * Store tokens securely using HttpOnly cookies in production\n   * Falls back to localStorage in development\n   */\n  private storeTokens(accessToken: string, refreshToken: string): void {\n    if (process.env.NODE_ENV === 'production') {\n      // In production, we'd set HttpOnly cookies via the backend\n      // For now, store in localStorage with additional security\n      const tokenData = {\n        token: accessToken,\n        refresh: refreshToken,\n        timestamp: Date.now()\n      };\n      \n      // Encrypt token data if crypto is available\n      if (window.crypto && window.crypto.subtle) {\n        // Store encrypted tokens (simplified implementation)\n        localStorage.setItem('authData', btoa(JSON.stringify(tokenData)));\n      } else {\n        localStorage.setItem('authToken', accessToken);\n        localStorage.setItem('refreshToken', refreshToken);\n      }\n    } else {\n      localStorage.setItem('authToken', accessToken);\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n  }\n\n  /**\n   * Retrieve stored tokens\n   */\n  private getStoredTokens(): { accessToken: string | null; refreshToken: string | null } {\n    if (process.env.NODE_ENV === 'production') {\n      try {\n        const authData = localStorage.getItem('authData');\n        if (authData) {\n          const decoded = JSON.parse(atob(authData));\n          // Check if token is not expired (24 hours)\n          if (Date.now() - decoded.timestamp < 24 * 60 * 60 * 1000) {\n            return {\n              accessToken: decoded.token,\n              refreshToken: decoded.refresh\n            };\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to decode stored auth data');\n      }\n    }\n    \n    return {\n      accessToken: localStorage.getItem('authToken'),\n      refreshToken: localStorage.getItem('refreshToken')\n    };\n  }\n\n  /**\n   * Login with credentials\n   */\n  async login(credentials: { username: string; password: string }): Promise<AuthResponse> {\n    try {\n      const response = await api.post<AuthResponse>('/auth/login/', credentials);\n      const { access_token, refresh_token } = response.data;\n      \n      this.storeTokens(access_token, refresh_token);\n      this.scheduleTokenRefresh(access_token);\n      \n      return response.data;\n    } catch (error) {\n      errorLogger.handleError(error, {\n        component: 'AuthService',\n        action: 'Login',\n        userMessage: 'Login failed. Please check your credentials.'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshToken(): Promise<string | null> {\n    try {\n      const { refreshToken } = this.getStoredTokens();\n      \n      if (!refreshToken) {\n        this.logout();\n        return null;\n      }\n\n      const response = await api.post<{ access_token: string }>('/auth/refresh/', {\n        refresh_token: refreshToken\n      });\n\n      const { access_token } = response.data;\n      \n      // Update only the access token, keep the refresh token\n      const { refreshToken: storedRefresh } = this.getStoredTokens();\n      if (storedRefresh) {\n        this.storeTokens(access_token, storedRefresh);\n        this.scheduleTokenRefresh(access_token);\n      }\n\n      return access_token;\n    } catch (error) {\n      errorLogger.handleError(error, {\n        component: 'AuthService',\n        action: 'Token Refresh',\n        userMessage: 'Session expired. Please log in again.'\n      });\n      \n      // Force logout on refresh failure\n      this.logout();\n      return null;\n    }\n  }\n\n  /**\n   * Schedule automatic token refresh before expiration\n   */\n  private scheduleTokenRefresh(token: string): void {\n    try {\n      // Decode JWT to get expiration time (simplified)\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const expirationTime = payload.exp * 1000;\n      const currentTime = Date.now();\n      const timeUntilRefresh = expirationTime - currentTime - 5 * 60 * 1000; // 5 minutes before expiry\n\n      if (timeUntilRefresh > 0) {\n        this.refreshTokenTimeout = setTimeout(() => {\n          this.refreshToken();\n        }, timeUntilRefresh);\n      }\n    } catch (error) {\n      console.warn('Failed to schedule token refresh:', error);\n    }\n  }\n\n  /**\n   * Get current access token\n   */\n  getAccessToken(): string | null {\n    const { accessToken } = this.getStoredTokens();\n    return accessToken;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    const { accessToken } = this.getStoredTokens();\n    return !!accessToken;\n  }\n\n  /**\n   * Logout and clear all authentication data\n   */\n  logout(): void {\n    // Clear timeout\n    if (this.refreshTokenTimeout) {\n      clearTimeout(this.refreshTokenTimeout);\n      this.refreshTokenTimeout = undefined;\n    }\n\n    // Clear stored tokens\n    localStorage.removeItem('authToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('authData');\n\n    // Clear any other user-related data\n    localStorage.removeItem('userProfile');\n\n    // Redirect to login\n    if (window.location.pathname !== '/login') {\n      window.location.href = '/#/login';\n    }\n  }\n\n  /**\n   * Validate token format (basic validation)\n   */\n  private isValidTokenFormat(token: string): boolean {\n    return token.split('.').length === 3; // JWT format check\n  }\n\n  /**\n   * Initialize auth service on app startup\n   */\n  initialize(): void {\n    const { accessToken } = this.getStoredTokens();\n    if (accessToken && this.isValidTokenFormat(accessToken)) {\n      this.scheduleTokenRefresh(accessToken);\n    }\n  }\n}\n\nexport const authService = new AuthService();\nexport default authService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}